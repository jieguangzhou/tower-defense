### 哲学思路
通过GIthub issue管理任务，完成PR流程。

### 具体操作流程
以下是一个code agent的prompt, 所有的任务都围绕一个预置的prompt展开, 预置的prompt见最后：

运行（codex为例子）

```
/prompts.implement 1
```

- 然后agent会自动了解issue需求，然后提PR。
- 当提了PR之后，会在本地进行对应的测试验收。验收通过合并代码到main分支。
- 如果验收不通过，则通过交互来修正代码，直到验收通过为止。

以下是一个对话的记录供参考:

```
>> /prompts.implement 8
>> 提交失败了，这是正常游戏，请梳理逻辑并修复 {\"runId\":\"...."}
>> 所有的拒绝逻辑都要补充日志来说明为什么不通过
>> 你把启动资金算漏了吧，启动资金和卖塔的资金也要加上，并且加一定的容错
>> 前端有export const MONSTERS, 这个数据，应该前后端一起使用来保持,不要定义两套，现在的计算也是有问题的，请重新复核一下计算方法 
>> /prompts.implement 10
>> 根据当前的实现梳理出完整的权威校验，防重放，防刷磅的逻辑，需要完整的逻辑和计算公式。更新到SECURITY.md中。从以下4个角度撰写:
   - 排行榜在“客户端不可信”前提下的校验
   - 你采用的服务端校验策略：服务端如何判定“是否入榜”
   - 防重放/防刷榜的策略
   - 局限性、薄弱点与应对方法
>> 你重新提交一个pr提交这个更新，这个分支已经被合并了
```

### 预置的prompt

```
请实现 Issue #$1，并提交一个 Pull Request 关联该 Issue。

## 工作流要求（必须遵守）
1) 同步最新 main（fetch/pull，确保基于最新 main）
2) 从最新 main 创建新分支：
   - 分支名：issue-$1/<short-slug>
3) 开发完成后：
   - 1–3 个可审查的 commits（按“可回滚/可定位”切分）
   - 创建 PR，并在 PR 描述中使用 “Fixes #$1” 或 “Closes #$1” 关联 Issue

## 前置理解要求（必须遵守）
A) 读取 Issue #$1 的正文与评论（评论里可能有补充方案/约束/验收口径变更）。  
B) **检查是否存在父 Issue / 关联的上游背景**：
   - 如果 Issue #$1 的描述/评论/任务列表/引用链接中出现父 Issue（例如 “Parent: #X”、“Part of #X”、“Blocked by #X”、“Sub-issue of #X” 等），则必须打开父 Issue #X（含评论）并提炼关键上下文：
     - 目标与范围（What / Not in scope）
     - 已定的架构决策与约束（Decisions / Constraints）
     - 当前 Issue 在整体路线中的位置与接口契约（Contract）
   - 只提炼“对实现本 Issue 必要的”上下文，不做大范围重构或扩展。

## 最高优先级原则（非常重要）
- **只为当前 Issue 的明确需求负责**：不做“顺手优化”、不引入额外能力
- **不做向后兼容**：除非 Issue 明确要求，否则不要为了兼容旧行为/旧接口/旧数据格式而添加额外分支、兼容层或保留路径；允许做明确 breaking change，并把影响写清楚
- **不扩展 API 面**：除非必须，否则不新增公共接口/配置项/参数；若必须新增，要极少且理由清晰
- **最小改动面**：改动尽量局部化，避免跨模块重构

## Pro 级实现准则（追求“巧夺天工”但不复杂）
### A) 先立“意图与不变量”（开工前必须写出来）
在开始编码前，先写一个 8–12 行清单（短、硬、可映射到改动）：
- Intent：本次改动要达成的唯一结果（1–2 行）
- Invariants：必须保持的系统不变量（2–4 条）
- Parent Context (if any)：来自父 Issue 的 2–5 条关键约束/契约（仅与本 Issue 强相关）
- Breaking Changes：不向后兼容会破坏什么（1–3 条），以及推荐迁移/替代方式（1–3 条）
- Boundaries：明确不做什么（2–4 条）
- Failure Modes：最可能出错的 2 个点，以及如何让它“易发现、易定位”

### B) 代码结构
- 用“清晰控制流 + 明确数据形态”解决问题，避免技巧性写法
- 优先减少状态与分支数量；能合并路径就合并
- 把关键逻辑收敛到少数可命名的函数/对象中（命名即文档）
- 注释只写“为什么”，不写“是什么”；不重复代码能看出的内容

### C) 可维护与易调试（必须）
- 关键路径补充高信息密度日志：
  - 回答：发生了什么、关键参数是什么、下一步是什么
  - 避免刷屏；只在边界、分支点、错误点记录
- 对边界条件做显式校验：
  - 失败信息必须可行动（告诉我怎么修/怎么看）
- 避免隐藏副作用：减少隐式全局、减少跨层耦合

### D) 正确性与验证（必须）
- 优先补充或更新自动化测试（单测/集成择其合适），覆盖：
  - 正常路径
  - 关键边界
  - 失败路径（至少 1 条）
- 若确实无法写测试（必须给出理由），则提供可复现的手动验证步骤：
  - 命令、输入、预期输出、如何判断成功/失败
- 自检：lint/format/test 全通过（若项目有）

## 交付与 PR 规范（必须）
- PR 标题：动词开头、清晰描述变更
- PR 描述必须包含：
  - Fixes #$1
  - Intent & Invariants（摘录你开工前那份清单）
  - Parent Context（如果有父 Issue，用 2–5 条 bullet 写清“我遵守了哪些上游契约/约束”）
  - Breaking Changes（明确：不向后兼容的点、迁移/替代做法、影响范围）
  - 实现要点（3–6 条，强调关键取舍）
  - 如何验证（命令/步骤）
  - 风险点与回滚方式（1–2 条，务实即可）

## 严禁项
- 不做向后兼容层、不保留旧路径（除非 Issue 明确要求）
- 不引入新框架/新依赖/新配置体系（除非 Issue 明确要求且别无选择）
- 不进行大范围重构来“顺便变好看”

现在开始：读取 Issue #$1（含评论）→ 如有父 Issue 则读取父 Issue（含评论）→ 基于最新 main 开分支 → 完成实现 → 测试/验证 → 提交 PR 并关联 Issue。


```
